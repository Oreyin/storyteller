//used for all file system manipulation
var fs = require('fs'); 

//used for file path manipulation 
var path = require('path'); 

//This code collects data from an editor and generates events and other data. When requested it
//prepares it for delivery to the playback server and others who request it.

//************************* Title and Description of Playback *************************
//holds the title and description of a playback
var playbackDescription = {
    title: "Playback",
    description: ""
};

//************************* Events *************************
//holds all of the events generated by the editor in the order that they occur
//these will be delivered to the playback code for display
var codeEvents = []; 

//every single code event generated by the editor will get a unique id.  
//this is used to assign unique ids to the code events
var autoGeneratedEventId = 0;

//************************* Comments *************************
//this will hold comments added during a playback
var comments = {};

//************************* Files and Directories *************************
//an object with all of the file objects in the file system keyed by file id
var allFiles = {};

//an object with all of the directory objects in the file system keyed by dir id
var allDirs = {};

//used to generate file and directory ids
var autoGeneratedFileId = 0;
var autoGeneratedDirId = 0; 

//insert events need to know their previous neighbor so that they can be placed in 
//the correct position during playback. Delete events need to know the ids of the 
//insert events that are being deleted.
//Therefore, as each file is edited there will be a shadow data structure that 
//stores minimal insert events that are currently in the file. They are 2D arrays 
//so that they can mimick the rows and columns of the file. Instead of storing simple 
//characters, these 2D arrays store minimal insert events (insert events have the character and 
//unique id in them). This shadow data structure will hold newline characters as well.
//allInsertEventsByFile = {
//  fileId-1: [[a-insEv, b-insEv, c-insEv, \n-insEv]
//             [d-insEv, e-insEv, f-insEv, \n-insEv]
//	           [g-insEv, h-insEv, i-insEv]],
//  fileId-2: [[1-insEv, 2-insEv, 3-insEv, \n-insEv]
//             [4-insEv, 5-insEv, 6-insEv, \n-insEv]
//             [7-insEv, 7-insEv, 8-insEv]]
//}
var allInsertEventsByFile = {};


//Holds the mappings between file/dir paths to ids. All paths are relative to a project dir.
//Every file and dir have an id that is assigned when the file/dir is recognized by the system. 
//This id never changes but file paths do change. For most storyteller related activity we use 
//ids not paths, however, editors and ide's do not know about our ids so we have to do a mapping 
//from path to id. When a file/dir is created an entry is added to allFiles/allDirs and an entry 
//is made to this map. When a path changes due to a file/dir move or rename the mappings are 
//updated to reflect the changes. When a file/dir is deleted the entries are deleted.
//
//pathToIdMap = {
//  "/": "dirId-0",
//  "/dir/": "dirId-1",
//  "/dir/file.txt": "fileId-0"
//};
var pathToIdMap = {};
//TODO separate this into a file and dir path to id maps

//holds information about which files/directories should be ignored. This comes from an optional file
//that may be in the project directory, st-ignore.json. This is comparable to git's .gitignore (but
//does not have the same syntax)
var storytellerIgnoreData = {};

//************************* Developers *************************
//create an anonymous developer 
var anonDeveloper = {
	id: "", //id will be filled in after a branch id has been created
	firstName: "Anonymous",
	lastName: "Developer", 
	email: "anon@mail.com"
};

//used to assign values to developers
var autoGeneratedDeveloperId = 0;

//an object with all of the developers keyed by their id
var allDevelopers = {};

//create an anonymous developer group to hold the anonymous dev in it
var anonDevgroup = {
	id: "", //id will be filled in after a branch id has been created
	memberIds: []
}
//used to assign values to developer groups
var autoGeneratedDeveloperGroupId = 0;

//an object with all of the developer groups
var allDeveloperGroups = {};

//all new events will be assigned to the current developer group. The user can change the current 
//developer group from the IDE.
//make the anonymous developer group the current one
var currentDeveloperGroup = anonDevgroup;

//************************* Branch Identity *************************
//every branch has an id that is used in id generation for event ids, file ids, etc.
var branchId;

//this holds the lineage of all branches
var branchAncestry;

//*****************************************************************************
//                         Branch related code
//                         -------------------
// This code has to do with managing the branch ids and ancestry of new branches
//*****************************************************************************
/*
 * Used to create a new branch id when a new branch is created. A new branch is 
 * created when:
 * - a new folder is opened for the first time
 * - the user downloads a playback
 * The id is not guaranteed to be unique among all other storyteller repos. It 
 * is possible for two repos to have the same branch id but with a 5 digit base
 * 62 number it is about a 1 in a billion chance.
 */ 
function createRandomBranchId() {

    //create a 5 digit random number (in base 62: 0-9,a-z,A-Z) between 00000-ZZZZZ or 0-916,132,832
    branchId = createRandomNumberBase62(5);
}
/*
 * Creates a random number using base 62. The digits are 0-9, a-z, A-Z. The user specifies how many digits they would like
 * the number to be.
 */
function createRandomNumberBase62(numDigits) {
    
    //a 'numDigits' digit random number (in base 62: 0-9,a-z,A-Z)
    var randomId = "";

    //the 62 digits that are available
    var digits = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
    
    //for each digit
    for(var i = 0;i < numDigits;i++) {
        
        //pick a random number between 0-61
        var randPos = Math.floor(Math.random() * 62);

        //add a random digit to the result
        randomId += digits[randPos];
    }

    return randomId;
}
//*****************************************************************************
//                         File/dir related code
//                         ---------------------
// This code has to do with file system operations create/delete/rename/move
// for files and directories. Each function creates an event that gets added
// to the list of all events. Each function also may update the internal collection
// of file/dirs and update the pathToIdMap object that links paths to ids.   
//*****************************************************************************
/*
 * Creates a new file in the file system and an event to represent it.
 */
function createFile(fullPathToFile, newFilePath, newFileName, newFileParentPath, timestamp, markAsPermanentlyNotRelevant) {

    //if this should be ignored due to the st-ignore.json file
    if(!ignoreThisFileOrDir(newFilePath)) {
        
        //create an id for this file
        var newFileId = "fileId-" + branchId + "_" + autoGeneratedFileId;
        
        //get the id ready for the next file/dir
        autoGeneratedFileId++;

        //create a new file object
        var newFile = {
            id: newFileId,
            parentId: getIdFromDirPath(newFileParentPath),
            currentName: newFileName,
            isDeleted: false
        };

        //add the file to the object of all files
        allFiles[newFileId] = newFile;

        //make a connection between the file path and an id 
        addFilePathToIdMap(newFilePath, newFileId);
        
        //create a new empty 2D array to hold insert events for the default file
        allInsertEventsByFile[newFileId] = [];

        //create a new file event
        var createFileEvent = {
            id: "ev_" + branchId + "_" + autoGeneratedEventId, 
            timestamp: timestamp,
            type: "Create File",
            initialName: newFileName,
            fileId: newFileId,
            parentDirectoryId: newFile.parentId,
            createdByDevGroupId: currentDeveloperGroup.id
        };
                
        //increase the id so the next event has a unique id
        autoGeneratedEventId++;
        
        //if the user wants to mark this file as NOT relevant (because it is an existing file
        //that is being reconciled in a new project)
        if(markAsPermanentlyNotRelevant === true) {

            //pre-mark the event as not even possible to become relevant
            createFileEvent.permanentRelevance = "never relevant";
        }

        //add the event to the collection of all events
        codeEvents.push(createFileEvent);

        //occassionally a new file has something in it, for example, if a tool has generated the file
        //if the file has anything in it, take the contents and make them events in the system

        //open the file and read the text
        var fileText = fs.readFileSync(fullPathToFile, "utf8");
        
        //if there is anything in the new file
        if(fileText !== "") {

            //add the text into 
            insertText(newFilePath, fileText, 0, 0, false, [], new Date().getTime(), markAsPermanentlyNotRelevant);
        }
    }	    
}

/*
 * Creates a new directory in the file system and an event to represent it.
 */
function createDirectory(newDirPath, newDirName, newDirParentPath, timestamp, markAsPermanentlyNotRelevant) {

    //if this should be ignored due to the st-ignore.json file
    if(!ignoreThisFileOrDir(newDirPath)) {

        //create an id for this dir
        var newDirId = "dirId-" + branchId + "_" + autoGeneratedDirId;

        //get the id ready for the next file/dir
        autoGeneratedDirId++;		

        //create a new directory object
        var newDirectory = {
            id: newDirId,
            parentId: newDirParentPath ? getIdFromDirPath(newDirParentPath) : null, //root dir has no parent
            currentName: newDirName,
            isDeleted: false
        };

        //add the directory to the object of all directories
        allDirs[newDirId] = newDirectory;

        //make a connection between the dir path and an id 
        addDirPathToIdMap(newDirPath, newDirId);

        //create a new directory event
        var createDirectoryEvent = {
            id: "ev_" + branchId + "_" + autoGeneratedEventId, 
            timestamp: timestamp,
            type: "Create Directory",
            initialName: newDirName,
            directoryId: newDirId,
            parentDirectoryId: newDirectory.parentId,
            createdByDevGroupId: currentDeveloperGroup.id
        };

        //increase the id so the next event has a unique id
        autoGeneratedEventId++;
        
        //if the user wants to mark this directory as NOT relevant (because it is an existing directory
        //that is being reconciled in a new project)
        if(markAsPermanentlyNotRelevant === true) {

            //pre-mark the event as not even possible to become relevant
            createDirectoryEvent.permanentRelevance = "never relevant";
        }
                     
        //add the event to the collection of all events
        codeEvents.push(createDirectoryEvent);		
    }
}

/*
 * Renames a file in the file system and creates an event to represent it.
 */
function renameFile(newFilePath, newFileName, oldFilePath, timestamp) {

    //if this should be ignored due to the st-ignore.json file 
    if(!ignoreThisFileOrDir(newFilePath)) {
            
        //get the id of the renamed file
        var fileId = getIdFromFilePath(oldFilePath);
        
        //if the file is being tracked
        if(fileId) {

            //update the mapping from path to id
            updateFilePathToIdMap(oldFilePath, newFilePath);
            
            //get the old name of the file
            var oldFileName = allFiles[fileId].currentName;
            
            //update the current name of the file in the collection of all files
            allFiles[fileId].currentName = newFileName;

            //create a rename file event
            var renameFileEvent = {
                id: "ev_" + branchId + "_" + autoGeneratedEventId,
                timestamp: timestamp,
                type: "Rename File",
                fileId: fileId,
                newFileName: newFileName,
                oldFileName: oldFileName,
                createdByDevGroupId: currentDeveloperGroup.id
            };
                    
            //increase the id so the next event has a unique id
            autoGeneratedEventId++;
                
            //add the event to the collection of all events
            codeEvents.push(renameFileEvent);
        }
    }		
}

/*
 * Renames a dir in the file system and creates an event to represent it.
 */
function renameDir(newDirPath, newDirName, oldDirPath, timestamp) {

    //if this should be ignored due to the st-ignore.json file
    if(!ignoreThisFileOrDir(newDirPath)) {

        //get the id of the renamed dir
        var dirId = getIdFromDirPath(oldDirPath);

        //if the directory is being tracked
        if(dirId) {

            //get the old name of the dir
            var oldDirName = allDirs[dirId].currentName;

            //update the current name of the dir in the collection of all dirs
            allDirs[dirId].currentName = newDirName;

            //create a rename directory event
            var renameDirectoryEvent = {
                id: "ev_" + branchId + "_" + autoGeneratedEventId, 
                timestamp: timestamp,
                type: "Rename Directory",
                directoryId: dirId,
                newDirectoryName: newDirName,
                oldDirectoryName: oldDirName,
                createdByDevGroupId: currentDeveloperGroup.id
            };
                    
            //increase the id so the next event has a unique id
            autoGeneratedEventId++;
                
            //add the event to the collection of all events
            codeEvents.push(renameDirectoryEvent);	
            
            //update all of the path to id mappings for the renamed dir
            updateAllPathToIdMap(oldDirPath, newDirPath);
        }
    }
}

/*
 * Moves a file in the file system and creates an event to represent it.
 */
function moveFile(newFilePath, newFileParentPath, oldFilePath, oldFileParentPath, timestamp) {

    //if this should be ignored due to the st-ignore.json file
    if(!ignoreThisFileOrDir(newFilePath)) {
        
        //get the id of the moved file
        var fileId = getIdFromFilePath(oldFilePath);

        //if the file is being tracked
        if(fileId) {

            //update the mapping from path to id
            updateFilePathToIdMap(oldFilePath, newFilePath);
            
            //update the new parent of the file in the collection of all files
            allFiles[fileId].parentId = getIdFromDirPath(newFileParentPath);

            //create a move file event
            var moveFileEvent = {
                id: "ev_" + branchId + "_" + autoGeneratedEventId, 
                timestamp: timestamp,
                type: "Move File",
                fileId: fileId,
                fileName: allFiles[fileId].currentName,
                newParentDirectoryId: getIdFromDirPath(newFileParentPath),
                oldParentDirectoryId: getIdFromDirPath(oldFileParentPath),
                newParentDirectoryName: allDirs[getIdFromDirPath(newFileParentPath)].currentName,
                oldParentDirectoryName: allDirs[getIdFromDirPath(oldFileParentPath)].currentName,
                createdByDevGroupId: currentDeveloperGroup.id
            };
                    
            //increase the id so the next event has a unique id
            autoGeneratedEventId++;
                
            //add the event to the collection of all events
            codeEvents.push(moveFileEvent);			
        }
    }
}

/*
 * Moves a dir in the file system and creates an event to represent it.
 */
function moveDir(newDirPath, newDirParentPath, oldDirPath, oldDirParentPath, timestamp) {

    //if this should be ignored due to the st-ignore.json file 
    if(!ignoreThisFileOrDir(newDirPath)) {
	
        //get the id of the moved dir
        var dirId = getIdFromDirPath(oldDirPath); 
            
        //if the directory is being tracked
        if(dirId) {

            //update the new parent of the dir in the collection of all dirs
            allDirs[dirId].parentId = getIdFromDirPath(newDirParentPath);
            
            //currently only generate a single move directory event. We can pretty easily create
            //several move events for all of the files in the moved dir (recurse top down).

            //create a move directory event
            var moveDirectoryEvent = {
                id: "ev_" + branchId + "_" + autoGeneratedEventId, 
                timestamp: timestamp,
                type: "Move Directory",
                directoryId: dirId,
                directoryName: allDirs[dirId].currentName,
                newParentDirectoryId: getIdFromDirPath(newDirParentPath),
                oldParentDirectoryId: getIdFromDirPath(oldDirParentPath),
                newParentDirectoryName: allDirs[getIdFromDirPath(newDirParentPath)].currentName,
                oldParentDirectoryName: allDirs[getIdFromDirPath(oldDirParentPath)].currentName,
                createdByDevGroupId: currentDeveloperGroup.id
            };
                    
            //increase the id so the next event has a unique id
            autoGeneratedEventId++;
                
            //add the event to the collection of all events
            codeEvents.push(moveDirectoryEvent);
            
            //update all of the path to id mappings for the moved dir
            updateAllPathToIdMap(oldDirPath, newDirPath);
        }
    }
}

/*
 * Deletes a file or a directory in the file system. Since the file or dir may be gone from the file system
 * by the time this is called it is hard for the editors to know if the path refers to a file or a directory 
 * so we do a search and call the appropriate delete function.
 */
function deleteFileOrDirectory(deletedPath, timestamp) {
	
    //if this should be ignored due to the st-ignore.json file
    if(!ignoreThisFileOrDir(deletedPath)) {

        //attempt to get the id assuming it is a directory
        var id = getIdFromDirPath(deletedPath);
        
        //if an id is returned we know this is a directory
        if(id) {

            //delete a dir
            deleteDir(deletedPath, timestamp);

        } else { //there was no dir id, next try for a file id

            //attempt to get the file id 
            id = getIdFromFilePath(deletedPath);

            //if an id is returned we know this is a file
            if(id) {

                //delete a file
                deleteFile(deletedPath, timestamp);

            } else { //no file or dir id- error
            
                console.log("Error on delete!!!");
            }
        }
    }

	// //check the object of all files to see if this is a file
	// if(allFiles[id]) {
		
	// 	//delete a file
	// 	deleteFile(deletedPath, timestamp);
		
	// } else if(allDirs[id]) { //check to see if it is a dir
		
	// 	//delete a dir
	// 	deleteDir(deletedPath, timestamp);
		
	// } else { //error
		
	// 	console.log("Error on delete!!!");
	// }
}

/*
 * Deletes a file in the file system and creates an event to represent it.
 */
function deleteFile(deletedFilePath, timestamp) {

    //if this should be ignored due to the st-ignore.json file 
    if(!ignoreThisFileOrDir(deletedFilePath)) {
        
        //get the file id based on the file path
        var deletedFileId = getIdFromFilePath(deletedFilePath);
        
        //if the file is being tracked
        if(deletedFileId) {

            //delete the mapping from the old file path 
            removeFilePathToIdMap(deletedFilePath);
            
            //update the file in the collection of all files
            allFiles[deletedFileId].isDeleted = true;

            //create a delete file event
            var deleteFileEvent = {
                id: "ev_" + branchId + "_" + autoGeneratedEventId, 
                timestamp: timestamp,
                type: "Delete File",
                fileId: deletedFileId,
                fileName: allFiles[deletedFileId].currentName,
                parentDirectoryId: allFiles[deletedFileId].parentId,
                createdByDevGroupId: currentDeveloperGroup.id
            };
                    
            //increase the id so the next event has a unique id
            autoGeneratedEventId++;
                
            //add the event to the collection of all events
            codeEvents.push(deleteFileEvent);	
        }
    }
}

/*
 * Deletes a dir in the file system and creates an event to represent it.
 */
function deleteDir(deletedDirPath, timestamp) {

    //if this should be ignored due to the st-ignore.json file 
    if(!ignoreThisFileOrDir(deletedDirPath)) {

        //get the deleted dir id based on the dir path
        var deletedDirId = getIdFromDirPath(deletedDirPath);

        //if the directory is being tracked
        if(deletedDirId) {

            //go through all of the dirs 
            for(var dirId in allDirs) {
                if(allDirs.hasOwnProperty(dirId)) {

                    //if a dir has the deleted dir as a parent AND
                    //it has not already been deleted
                    if(allDirs[dirId].parentId === deletedDirId &&
                    allDirs[dirId].isDeleted === false) {
                        
                        //delete the sub-dir in the deleted directory
                        deleteDir(getPathFromId(dirId), timestamp);
                    }
                }
            }
            
            //go through all of the files 
            for(var fileId in allFiles) {
                if(allFiles.hasOwnProperty(fileId)) {
                    
                    //if a file has the deleted dir as a parent AND
                    //it has not already been deleted
                    if(allFiles[fileId].parentId === deletedDirId &&
                    allFiles[fileId].isDeleted === false) {
                        
                        //delete the file in the deleted directory
                        deleteFile(getPathFromId(fileId), timestamp);
                    }
                }
            }
            
            //delete the mapping from the old dir path 
            removeDirPathToIdMap(deletedDirPath);
            
            //update the dir in the collection of all files
            allDirs[deletedDirId].isDeleted = true;

            //create a delete directory event
            var deleteDirectoryEvent = {
                id: "ev_" + branchId + "_" + autoGeneratedEventId, 
                timestamp: timestamp,
                type: "Delete Directory",
                directoryId: deletedDirId,
                directoryName: allDirs[deletedDirId].currentName,
                parentDirectoryId: allDirs[deletedDirId].parentId,
                createdByDevGroupId: currentDeveloperGroup.id
            };
                    
            //increase the id so the next event has a unique id
            autoGeneratedEventId++;
                
            //add the event to the collection of all events
            codeEvents.push(deleteDirectoryEvent);	
        }
    }
}

/*
 * Checks to see if the file/dir in the path was requested to be hidden per the project's st-ignore.json file. 
 * 
 * The ignore data comes from a json file with this format:
 * {
 *      ignoredFileExtensions: [".o", ".obj"], 
 *      ignoredFiles: ["todo.txt"], 
 *      ignoredDirectories: ["/bin", "/test/mocks", "/a/b/c"]
 * }
 * File extensions are tested for exact equality. In the example above all files with the extension .o and .obj will 
 * be ignored (the dots are required in the string).
 * 
 * File names are tested just for their name with an extension. st-ignore files should not include any part of the 
 * path other than the file name and extension. In the example above any file called todo.txt anywhere in the 
 * project will be ignored (there might be zero or more files with this name and they will all be ignored)
 * 
 * Directories must be specified from the root of the storyteller project. In the example above any changes made 
 * inside the exact directories specified will be ignored. 
 */
function ignoreThisFileOrDir(pathToFileOrDir) {

    //assume that the file or dir should NOT be ignored
    var retVal = false;

    //pick apart the file/dir path 
    var fileInfo = path.parse(pathToFileOrDir);

    //don't track  anything in the .storyteller directory
    if(pathToFileOrDir.indexOf(".storyteller") !== -1) { 
        
        retVal = true;

    } else if(fileInfo.base === "st-ignore.json") { //or the file named st-ignore.json
        
        retVal = true;

    } else if(storytellerIgnoreData.ignoredFileExtensions.indexOf(fileInfo.ext) !== -1) { //or if the file extension is present
        
        retVal = true;

    } else if(storytellerIgnoreData.ignoredFiles.indexOf(fileInfo.base) !== -1) { //or if the file name is present
        
        retVal = true;

    } else { //last check for the directories

        //now check the directories
        for(var i = 0;i < storytellerIgnoreData.ignoredDirectories.length;i++) {
            
            //if the path starts with any of the ignored directories it should be ignored
            if(pathToFileOrDir.startsWith(storytellerIgnoreData.ignoredDirectories[i])) {
                
                retVal = true;
                break;
            }    
        }
    }

    //if there is a hidden file/dir on the path
    if(retVal) {

        //debug
        //console.log(`Hidden file/dir: ${pathToFileOrDir}`);
    }

    return retVal;
}
/*
 * Store the storyteller ignore data 
 */
function loadStorytellerIgnoreFile(stIgnoreData) {
    
    //store the data in the global object 
    storytellerIgnoreData = stIgnoreData;
}
//*****************************************************************************
//                         Path mapping related code
//                         -------------------------
// This code has to do with the mapping of paths to storyteller file/dir ids. 
//*****************************************************************************
/*
 * Adds a file path to file id mapping
 */
function addFilePathToIdMap(filePath, fileId) {
    
    //add the file path to file id mapping
    pathToIdMap[filePath] = fileId;
}

/*
 * Adds a dir path to dir id mapping. It makes sure the dir path ends with a slash '/'
 */
function addDirPathToIdMap(dirPath, dirId) {

    //make sure the dir path ends with a slash
    dirPath = addEndingPathSeparator(dirPath);

    //add the dir path to dir id mapping
    pathToIdMap[dirPath] = dirId;
}

/*
 * Removes a file path from the mapping
 */
function removeFilePathToIdMap(filePath) {
    
    //remove the file path to file id mapping
    delete pathToIdMap[filePath];
}

/*
 * Removes a dir path from the mapping. It makes sure the dir path ends with a slash '/'
 */
function removeDirPathToIdMap(dirPath) {

    //make sure the dir path ends with a slash
    dirPath = addEndingPathSeparator(dirPath);

    //delete the dir path to dir id mapping
    delete pathToIdMap[dirPath];
}

/*
 * Returns a file id from a file path
 */
function getIdFromFilePath(filePath) {

    return pathToIdMap[filePath];
}

/*
 * Returns a dir id from a dir path. It makes sure the dir path ends with a slash '/'
 */
function getIdFromDirPath(dirPath) {

    //make sure the dir path ends with a slash
    dirPath = addEndingPathSeparator(dirPath);

    return pathToIdMap[dirPath];
}

/*
 * Takes in a dir path and makes sure it has an ending slash
 */
function addEndingPathSeparator(dirPath) {
    
    //if the dir path does not end with a slash
    if(dirPath[dirPath.length - 1] !== "/") {

        //add the ending slash so all paths look like /path/to/dir/
        dirPath += "/";
    }

    return dirPath;
}

/*
 * Updates the pathToIdMap object removing the old path to id mapping and creating a
 * new mapping based on a new path.
 */
function updateFilePathToIdMap(oldFilePath, newFilePath) {
    
	//get the file/dir id based on the old path
    var id = pathToIdMap[oldFilePath];
    
    //delete the mapping from the old path 
    delete pathToIdMap[oldFilePath];
    
    //create a new mapping from the new file/dir path to the id 
    pathToIdMap[newFilePath] = id;
}

/*
 * Used to update the paths of all the files/dirs under a dir that is moved or renamed.
 */
function updateAllPathToIdMap(oldDirPath, newDirPath) {
	
    //add the ending separator if necessary
    oldDirPath = addEndingPathSeparator(oldDirPath);
    newDirPath = addEndingPathSeparator(newDirPath);

	//holds all the new paths and ids of the files/dirs that have moved 
	var movedPaths = {};
    
    //holds all of the paths that need to be deleted from pathToIdMap
	var deletePaths = [];
	
    //go through all of the existing path to id mappings 
    for(var path in pathToIdMap) {
        if(pathToIdMap.hasOwnProperty(path)) {
		
			//if the old path is at the beginning of another path
            if(path.startsWith(oldDirPath)) {

				//get the new updated path
				var updatedPath = path.replace(oldDirPath, newDirPath);
				
                //add the new updated path and the id associated with it to a temporary object 
                //we don't want to change the object it in the middle of a loop through the properties
				movedPaths[updatedPath] = pathToIdMap[path];

				//store the path to remove from the pathToId map later 
				deletePaths.push(path);
			}
        }
    }

	//delete the mapping (don't want to add to the object in the middle of a loop
	//iterating over the properties)
	for(var i = 0;i < deletePaths.length;i++) {		

        //get rid of old mapping
		delete pathToIdMap[deletePaths[i]];
	}

    //now add the new mappings back to the object
	//go through all of the moved paths 
    for(var path in movedPaths) {
        if(movedPaths.hasOwnProperty(path)) {

			//add the new path to id mapping back to the original 
			pathToIdMap[path] = movedPaths[path];
		}
	}
}

/*
 * Get a file/dir path from an id. This is a slow operation because we are trying
 * to get a key from a value and have to iterate through the map. This should be used
 * with caution.
 */
function getPathFromId(id) {
	
	//if the id is present this will be the path
	var pathFromId = "";
	
	//go through all of the path to id mappings
	for(var path in pathToIdMap) {
		if(pathToIdMap.hasOwnProperty(path)) {
			
			//if an id is found that matches
			if(pathToIdMap[path] === id) {
				
				//store the path with the corresponding id
				pathFromId = path;
				
				//stop looking
				break;
			}
		}
	}
	
	return pathFromId;
}

//*****************************************************************************
//                         Insert/delete related code
//                         --------------------------
// This code has to do with the inserting and deleting of code as a result of 
// the user typing in the text editor. A handler is called for every insert or 
// delete (which may happen in groups of text for cuts and pastes). An event is
// generated for each insert/delete. The events are stored in an array that will
// get sent to the playback window for playback but references to the inserts are 
// also stored in a two dim array that always mirrors the content of the files
//*****************************************************************************
/*
 * Handles new text in the editor. An insert event is created and added to the list of all events.
 * The shadow data structure that mimicks the state of the editor is also updated. 
 */
function insertText(filePath, insertedText, startRow, startCol, isPaste, pastedInsertEventIds, timestamp, markAsPermanentlyNotRelevant) {
    
    //if this should be ignored due to the st-ignore.json file 
    if(!ignoreThisFileOrDir(filePath)) {

        //measuring the impact of a text edit
        //var t0 = Date.now();
        
        //get the file id associated with the file where the change takes place
        var fileId = getIdFromFilePath(filePath);
            
        //if the file is being tracked
        if(fileId) {

            //get the 2D event array that shadows the contents of a file based on the file id
            var allInsertEventsByPos = allInsertEventsByFile[fileId];
            
            //where the insert starts
            var row = startRow;
            var col = startCol;
            
            //for all of the new text that is being inserted 
            for(var i = 0;i < insertedText.length;i++) {

                //create a code event
                var newInsertTextEvent = {
                    id: "ev_" + branchId + "_" + autoGeneratedEventId,
                    timestamp: timestamp,
                    type: "Insert",
                    character: insertedText[i],
                    previousNeighborId: getPreviousNeighborId(row, col, allInsertEventsByPos),
                    createdByDevGroupId: currentDeveloperGroup.id,
                    lineNumber: row + 1,
                    column: col + 1,
                    fileId: fileId,
                    pastedEventId: null
                };
                
                //increase for the next id
                autoGeneratedEventId++;

                //if this text was pasted
                if(isPaste) {

                    //if there are some corresponding event ids that go with the text
                    if(pastedInsertEventIds.length > 0) {

                        //get the corresponding paste id
                        newInsertTextEvent.pastedEventId = pastedInsertEventIds[i];
                    
                    } else { //there are no paste ids, this was a paste from an outside source

                        //indicate a paste from another source
                        newInsertTextEvent.pastedEventId = "other";
                    }
                }

                //if the user wants to mark this insert as NOT relevant (because it is text from an existing file
                //that is being reconciled in a new project)
                if(markAsPermanentlyNotRelevant === true) {

                    //pre-mark the event as not even possible to become relevant
                    newInsertTextEvent.permanentRelevance = "never relevant";
                }
                
                //add the event to the collection
                codeEvents.push(newInsertTextEvent);

                //insert the new event in the correct position of the shadow structure
                addInsertEventByPos(newInsertTextEvent, row, col, allInsertEventsByPos);

                //if this code character was a newline
                if(insertedText[i] === "\n") {

                    //go to the next row
                    row++;

                    //set the column back to the beginning of the line
                    col = 0;

                } else { //a non-newline character

                    //move to the next column
                    col++;
                }
            }
        }
        //var t1 = Date.now();
        //console.log("Insert time: " + (t1 - t0) + " milliseconds.");
    }
}

/*
 * Handles deleted text from the editor. A delete event is created and added to the list of all events.
 * The shadow data structure that mimicks the state of the editor is also updated. 
 */
function deleteText(filePath, startRow, startCol, numElementsToDelete, timestamp, markAsPermanentlyNotRelevant) {
    
    //if this should be ignored due to the st-ignore.json file 
    if(!ignoreThisFileOrDir(filePath)) {

        //measuring the impact of a text edit
        //var t0 = Date.now();
        
        //get the file id associated with the file where the change takes place
        var fileId = getIdFromFilePath(filePath);
            
        //if the file is being tracked
        if(fileId) {

            //get the 2D event array that shadows the contents of a file based on the file id
            var allInsertEventsByPos = allInsertEventsByFile[fileId];

            //the position we will remove from
            var row = startRow;
            var col = startCol;

            //for each element we delete we will delete from the same starting position
            //all values in front will shift back
            for(var i = 0;i < numElementsToDelete;i++) {

                //get the insert event that is being deleted
                var insertEventBeingDeleted = getEvent(row, col, allInsertEventsByPos);

                //TODO if we want to keep this (knowing when an insert was deleted) we'll have to update
                //the insert events in codeEvents because what is in allInsertEventsByFile[fileId] may be 
                //different objects than in codeEvents. binary search on the events in codeEvents by timestamp??        
                
                //update the insert event to hold its delete time
                //insertEventBeingDeleted.deletedAtTimestamp = timestamp; 

                //create a delete event
                var newDeleteTextEvent = {
                    id: "ev_" + branchId + "_" + autoGeneratedEventId, 
                    timestamp: timestamp,
                    type: "Delete",
                    character: insertEventBeingDeleted.character,
                    previousNeighborId: insertEventBeingDeleted.id,
                    createdByDevGroupId: currentDeveloperGroup.id,
                    lineNumber: row + 1,
                    column: col + 1,
                    fileId: fileId
                };
                
                //increase for the next id
                autoGeneratedEventId++;
                
                if(markAsPermanentlyNotRelevant === true) {

                    //pre-mark the event as not even possible to become relevant
                    newDeleteTextEvent.permanentRelevance = "never relevant";
                }

                //add the event to the collection
                codeEvents.push(newDeleteTextEvent);

                //remove the insert event from the shadow structure at the point of the first
                //character that is deleted
                removeInsertEventByPos(row, col, allInsertEventsByPos);  	
            }
        }            
        //var t1 = Date.now();
        //console.log("Delete time: " + (t1 - t0) + " milliseconds.");
    }
}

/*
 * Used to enter a new event in the shadow data structure that mimicks the file contents
 */
function addInsertEventByPos(fullEvent, row, col, allInsertEventsByPos) {
	
    //create a minimal insert event from the full event
    var event = {
        id: fullEvent.id,
        character: fullEvent.character
    };
    
	//if this is the first insert on a new row
	if(allInsertEventsByPos.length === row) { 
		
		//create a new row at the bottom
		allInsertEventsByPos.push([]);
				
		//add the id to the new array
		allInsertEventsByPos[row].push(event);
		
	} else { //the insert is in an existing row
		
		//insert somewhere in the middle
		allInsertEventsByPos[row].splice(col, 0, event);
	}
	
	//if the new character was a newline character
	if(event.character === "\n") {
		
		//get the rest of the line after the newline character
		var restOfLine = allInsertEventsByPos[row].splice(col + 1, allInsertEventsByPos[row].length - col);
		
		//add a new empty row that the newline created
		allInsertEventsByPos.splice(row + 1, 0, []); 
		
		//copy the remaining characters onto the new line
		for(var i = 0;i < restOfLine.length;i++) {
			
			allInsertEventsByPos[row + 1].push(restOfLine[i]);
		}
	}
}

/*
 * Used to remove an element from the shadow data structure 
 */
function removeInsertEventByPos(row, col, allInsertEventsByPos) {
	
	//if we are removing a new line
	if(allInsertEventsByPos[row][col].character === "\n") {

		//remove the newline character from its line
		allInsertEventsByPos[row].splice(col, 1);

		//if there is a 'next' row, move all the elements up to this row
		if(row + 1 < allInsertEventsByPos.length) {
			
			//get the next row (it may be an empty row)
			var copyElements = allInsertEventsByPos[row + 1].splice(0);
			
			//add the elements to the current row
			for(var i = 0;i < copyElements.length;i++) {
				
				allInsertEventsByPos[row].push(copyElements[i]);				
			}
			
			//remove the row that we copied all of the elements over
			allInsertEventsByPos.splice(row + 1, 1);
			
		} //else- this is the last row in the file- there is not another row after this one to copy over
			
	} else { //removing a non-newline

		//remove the id
		allInsertEventsByPos[row].splice(col, 1);
	}
	
	//if there is nothing left on the row
	if(allInsertEventsByPos[row].length === 0) {
		
		//remove the row
		allInsertEventsByPos.splice(row, 1);
	}
}

/*
 * This is used to retrieve a previous neighbor insert event based on the passed in row and column
 */
function getPreviousNeighborId(row, col, allInsertEventsByPos) {
	
    //id of the previous neighbor
	var retVal;
	
	//if we are asking for the previous neighbor of the very first element in the document
	if(row === 0 && col === 0) {
		
		//there is no previous neighbor
		retVal = "none";
		
	} else if(col === 0) { //previous neighbor of a first column
		
		//get the previous row (there will always be one)
		var previousRow = allInsertEventsByPos[row - 1];
		
		//go to the end of the previous row and return the last insert event
		var prevEvent = previousRow[previousRow.length - 1];

        //get the id of the previous neighbor
        retVal = prevEvent.id;
		
	} else { //not in the first col
		
		//go back one from the col and return it
		var prevEvent = allInsertEventsByPos[row][col - 1];

        //get the id of the previous neighbor
        retVal = prevEvent.id;
	}
	
	//return the id of the previous neighbor
	return retVal;
}

/*
 * This returns the id of the insert code event
 */
function getEvent(row, col, allInsertEventsByPos) {
	
	//default error message
	retVal = "ERROR ON ID";
	
	//if the row and column are good
	if((row >= 0 && row < allInsertEventsByPos.length) &&
	   (col >= 0 && col < allInsertEventsByPos[row].length)) {
		
		//return the id of the code
		retVal = allInsertEventsByPos[row][col];
	} 
	
	return retVal;
}

/*
 * Gets all the (minimal) events from a file in a range
 */
function getInsertEventsByPos(filePath, startRow, startCol, endRow, endCol) {
    
    //a list of the minimal events in the selected range
    var events = [];

    //get the file id associated with the file where the change takes place
    var fileId = getIdFromFilePath(filePath);
    
    //if there is a valid file id    
    if(fileId) {

        //get the 2D event array that shadows the contents of a file based on the file id
        var allInsertEventsByPos = allInsertEventsByFile[fileId];

        //where the insert starts
        var row = startRow;
        var col = startCol;
        
        //while the current position is not equal to the end position
        while(row !== endRow || col !== endCol) {

            //get the current (minimal) event
            var currentEvent = allInsertEventsByPos[row][col];
            
            //add it list 
            events.push(currentEvent);

            //if this code character was a newline
            if(currentEvent.character === "\n") {

                //go to the next row
                row++;

                //set the column back to the beginning of the line
                col = 0;

            } else { //a non-newline character

                //move to the next column
                col++;
            }
        }
    }

    return events;
}
//*****************************************************************************
//         Storing and retrieving playback and editor state related code
//         -------------------------------------------------------------
// This code has to do with the getting and setting playback data and editor state
// data. The data is set when storyteller starts up when there was a previous
// programming session. The data is read when the playback server requests it
// to generate an js/html file for playback. 
//*****************************************************************************
/*
 * This function is called by the playback code to get code events and developer info used
 * for playback.
 */
function getPlaybackData() {
		
    var playbackData = {};
    
    //add the data members    
    playbackData.codeEvents = codeEvents;
    playbackData.allFiles = allFiles;
    playbackData.allDirs = allDirs;
 	playbackData.allDevelopers = allDevelopers;
	playbackData.allDeveloperGroups = allDeveloperGroups;
    playbackData.currentDevGroupId = currentDeveloperGroup.id;
    playbackData.comments = comments;
    playbackData.playbackDescription = playbackDescription;
    playbackData.branchId = branchId;

    return playbackData;
}

/*
 * This function is called from an editor/IDE when restoring the state of a previous programming session.
 */
function setPlaybackData(playbackData) {
    
    codeEvents = playbackData.codeEvents;
    allFiles = playbackData.allFiles;
    allDirs = playbackData.allDirs;
    allDevelopers = playbackData.allDevelopers;
    allDeveloperGroups = playbackData.allDeveloperGroups;
    currentDeveloperGroup = playbackData.allDeveloperGroups[playbackData.currentDevGroupId];
    comments = playbackData.comments;       
    playbackDescription = playbackData.playbackDescription;
    branchId = playbackData.branchId;
}

/*
 * This function is called to get the previous state of the editor, in particular, the events that are currently in
 * the files and the path to id mappings. 
 */
function getEditorState() {

    var editorState = {};
    
    //add the data members
    editorState.pathToIdMap = pathToIdMap;
    editorState.allInsertEventsByFile = allInsertEventsByFile;
    editorState.autoGeneratedEventId = autoGeneratedEventId;
    editorState.autoGeneratedFileId = autoGeneratedFileId;
    editorState.autoGeneratedDirId = autoGeneratedDirId;
    editorState.autoGeneratedDeveloperId = autoGeneratedDeveloperId;
    editorState.autoGeneratedDeveloperGroupId = autoGeneratedDeveloperGroupId;
    
    return editorState;
}

/*
 * This function is called to restore a previous programming session.
 */
function setEditorState(editorState) {

    pathToIdMap = editorState.pathToIdMap;
    allInsertEventsByFile = editorState.allInsertEventsByFile;
    autoGeneratedEventId = editorState.autoGeneratedEventId;
    autoGeneratedFileId = editorState.autoGeneratedFileId;
    autoGeneratedDirId = editorState.autoGeneratedDirId;
    autoGeneratedDeveloperId = editorState.autoGeneratedDeveloperId;
    autoGeneratedDeveloperGroupId = editorState.autoGeneratedDeveloperGroupId;
}

/*
 * This function will return the paths to all the files in the system. This is used in reconciliation
 * to make sure the staryteller database mimicks the file system. 
 */
function getAllFilePaths() {
    
    //holds all the file paths being tracked by storyteller
    var allFilePaths = [];
    
    //go through each file/dir mapping
    for(var filePath in pathToIdMap) {
        if(pathToIdMap.hasOwnProperty(filePath)) {
            
            //if the file exists in the allFiles collection we know it is a file
            if(allFiles[getIdFromFilePath(filePath)]) {
                allFilePaths.push(filePath);                
            }
        }
    }
    
    return allFilePaths;
}

/*
 * This function will return the paths to all the directories in the system. This is used in reconciliation
 * to make sure the staryteller database mimicks the file system.
 */
function getAllDirPaths() {
		
    //holds all the dir paths being tracked by storyteller
    var allDirPaths = [];
        
    //go through each file/dir mapping
    for(var dirPath in pathToIdMap) {
        if(pathToIdMap.hasOwnProperty(dirPath)) {
            
            //if the dir exists in the allDirs collection we know it is a dir
            if(allDirs[getIdFromDirPath(dirPath)]) {
                allDirPaths.push(dirPath);                
            }
        }
    }
    
    return allDirPaths;
}

/*
 * This function gets all of the text in a file.
 */
function getText(pathToFile) {

    //get the id of the file
    var fileId = getIdFromFilePath(pathToFile);

    //if the file is being tracked
    if(fileId) {

        //get the shadow structure for the passed in path
        var allInsertEventsByPos = allInsertEventsByFile[fileId];

        //text in the file
        var text = "";
        
        //if there is a file
        if(allInsertEventsByPos) {

            //go through the entire 2D array of events    
            for(var line = 0;line < allInsertEventsByPos.length;line++) {
                for(var column = 0;column < allInsertEventsByPos[line].length;column++) {
                    
                    //append the code character to a string
                    text += allInsertEventsByPos[line][column].character;
                }
            }        

        } else { //there path to the file is incorrect

            //console.log("The file: " + pathToFile + " is not present");
        }
    }

    return text;
}

/*
 * indicates whether a file or directory is present.
 */
function isFileOrDirPresent(pathToFileOrDir) {
    
    //assume the file or dir is not present
    var retVal = false;
    
    //if there is a mapping from path to id then it is being tracked by storyteller
    if(getIdFromFilePath(pathToFileOrDir) || getIdFromDirPath(pathToFileOrDir) ){
        
        retVal = true;
    }
    
    return retVal;
}
//*****************************************************************************
//                        Developer related code
//                        ----------------------
// This code has to do with the manipulating developers and developer groups. 
//*****************************************************************************
/*
 * Creates an initial anonymous developer in case the user chooses not to create a dev.
 */
function createAnonymousDeveloper() {
    
    //create an id for the anonymous developer
    anonDeveloper.id = "devId-" + branchId + "_" + autoGeneratedDeveloperId;

    //update the sequence number for future developers
    autoGeneratedDeveloperId++

    //add the anonymous developer to the group of all developers
    allDevelopers[anonDeveloper.id] = anonDeveloper;

    //update the anonymous developer group to put the anonymous dev in it
    anonDevgroup.id = "devGroupId-" + branchId + "_" + autoGeneratedDeveloperGroupId;
    anonDevgroup.memberIds = [anonDeveloper.id];

    //update the sequence number for future dev groups
    autoGeneratedDeveloperGroupId++

    //add the anon dev group
    allDeveloperGroups[anonDevgroup.id] = anonDevgroup;

    //all new events will be assigned to the current developer group. The user can change the current 
    //developer group from the IDE.
    //make the anonymous developer group the current one
    var currentDeveloperGroup = anonDevgroup;
}
/*
 * Overwites data about the initial anonymous developer.
 */
function overwriteAnonDev(email, first, last) {
    
    //update the default anonymous developer with some info
    anonDeveloper.firstName = first;
	anonDeveloper.lastName = last; 
	anonDeveloper.email = email;
}

/*
 * Gets all of the developer objects in the active developer group
 */
function getAllDevsInActiveDevGroup() {
    
    //holds the developers who are in the current active developer group 
    var activeDevs = [];
    
    //go through all of the memberIds of the current dev group
    for(var i = 0;i < currentDeveloperGroup.memberIds.length;i++) {
        
        //get the dev object associated with the id
        activeDevs.push(allDevelopers[currentDeveloperGroup.memberIds[i]]);
    }
    
    return activeDevs;
}

/*
 * Gets all of the developer objects NOT in the active developer group
 */
function getAllDevsExceptThoseInActiveDevGroup() {
    
    //holds the developers who are NOT in the current active developer group 
    var inactiveDevs = [];
    
    //grab each of the developer objects from the hash table
    for (var devId in allDevelopers) {
        
        //if this is a developer property
        if (allDevelopers.hasOwnProperty(devId)) {
            
            //if the dev is not in the active dev group
            if(!currentDeveloperGroup.memberIds.includes(devId)) {
                
                //add the inactive dev to the list
                inactiveDevs.push(allDevelopers[devId]);
            } 
        }
    }
    
    return inactiveDevs;
}

/*
 * Creates a new developer and an accompanying developer group with just one dev.
 */
function createDeveloper(firstName, lastName, email) {

    //if the developer does not exist already
    if(getDeveloperByEmail(email) === null) {

        //create a new developer object
        var newDeveloper = {
            id: "devId-" + branchId + "_" + autoGeneratedDeveloperId,
            firstName: firstName,
            lastName: lastName,
            email: email
        };		

        //increase the id for the next dev
        autoGeneratedDeveloperId++;

        //if the developer is new add it to the developers object
        allDevelopers[newDeveloper.id] = newDeveloper;

        //create a new developer group with just that developer in it
        createDeveloperGroup([newDeveloper.id]);
    }

    return newDeveloper;
}

/*
 * Creates a new developer group and adds it to the collection of all dev groups
 */
function createDeveloperGroup(developerIds) {
	
	//create a new dev group
	var newDevGroup = {
		id: "devGroupId-" + branchId + "_" + autoGeneratedDeveloperGroupId,
		memberIds: developerIds
	};

	//create a new unique dev group id
	autoGeneratedDeveloperGroupId++;

	//add the new dev group 
	allDeveloperGroups[newDevGroup.id] = newDevGroup;
	
	return newDevGroup;
}

/*
 * Search for a developer by email address.
 */
function getDeveloperByEmail(email) {
	
	var retVal = null;
	
    //grab each of the developer objects from the hash table
    for (var devId in allDevelopers) {
        if (allDevelopers.hasOwnProperty(devId)) {
            
            //if the dev's email matches
            if(allDevelopers[devId].email === email) {
                
                //store the dev
                retVal = allDevelopers[devId];
                
                //stop looking
                break;
            }
        }
    }
    
	return retVal;
}

/*
 * Adds one or more developers from the active developer group
 */
function addDeveloperToActiveDeveloperGroup(devEmails) {
    
    //indicates whether all the devs were added
    var success = false;
    
    //get a copy of all of the devs in the current dev group
    var currentDevIds = currentDeveloperGroup.memberIds.slice(0);
    
    //holds all of the new devs that we will be adding to the active dev group
    var newDevIds = [];
    
    //go through all of the emails
    for(var i = 0;i < devEmails.length;i++) {
        
        //get the dev object (so we have access to the id)
        var newDev = getDeveloperByEmail(devEmails[i]);
        
        //if the dev was found (valid email) AND
        //the dev is not already in the current dev group
        if(newDev && !currentDevIds.includes(newDev.id)) {
            
            //add it to the list of new devs
            newDevIds.push(newDev.id);
            
        } else { //dev was not found OR already on the current dev group
            
            //if even one dev is not found or already present, say that none of the devs can be added
            newDevIds = [];
            break;
        }
    }

    //if the devs we are trying to add are valid
    if(newDevIds.length > 0) {
        
        //indicate success
        success = true;
                
        //add the ids of the devs to the list of existing devs
        currentDevIds = currentDevIds.concat(newDevIds);
        
        //sort the collection of dev ids (this is required for comparison in getDeveloperGroup)
        currentDevIds.sort();    
        
        //see if there is an existing dev group with exactly these memberIds
        var devGroup = getDeveloperGroup(currentDevIds);
        
        //if there is NOT already a developer group with the passed in developers 
        if(devGroup === null) {
            
            //create a new dev group
            devGroup = createDeveloperGroup(currentDevIds);	
        } 		
        
        //set this as the current dev group
        currentDeveloperGroup = devGroup;
    }    
    
    return success;
}

/*
 * Removes one or more developers from the active developer group
 */
function removeDeveloperFromActiveDeveloperGroup(devEmails) {
    
    //indicates whether a dev was removed
    var success = false;
    
    //get a copy of all of the devs in the current dev group
    var currentDevIds = currentDeveloperGroup.memberIds.slice(0);
    
    //ids of the devs we will remove
    var removeDevIds = [];
    
    //go through all of the emails
    for(var i = 0;i < devEmails.length;i++) {
        
        //get the dev object (so we have access to the id)
        var removeDev = getDeveloperByEmail(devEmails[i]);
        
        //if the dev was found (valid email) AND
        //the dev is in the current dev group
        if(removeDev && currentDevIds.includes(removeDev.id)) {
            
            //add it to the list of remove devs
            removeDevIds.push(removeDev.id);
            
        } else { //dev was not found OR not in the current dev group
            
            //if even one dev is not found or not present, say that none of the devs can be removed
            removeDevIds = [];
            break;
        }
    }

    //if the devs we are trying to remove exist AND
    //there will be at least one dev left in the group (don't want an empty dev group)
    if(removeDevIds.length > 0 && currentDevIds.length > removeDevIds.length) {

        //indicate success
        success = true;
                       
        //go through the valid devs that we will removed from the current devs 
        for(var i = 0;i < removeDevIds.length;i++) {
            
            //remove the devs
            currentDevIds.splice(currentDevIds.indexOf(removeDevIds[i]), 1);            
        }
                
        //see if there is an existing dev group with exactly these members
        var devGroup = getDeveloperGroup(currentDevIds);
        
        //if there is NOT already a developer group with the passed in developers 
        if(devGroup === null) {
            
            //create a new dev group
            devGroup = createDeveloperGroup(currentDevIds);	
        } 		
        
        //set this as the current dev group
        currentDeveloperGroup = devGroup;
    }        
    
    return success;
}

/*
 * Looks for a dev group with exactly the same memberIds as the passed in array of dev ids
 */
function getDeveloperGroup(developerIds) {

	//the developer group with all of the developers in it (if there is one)
	var retVal = null;
	
	//go through all of the dev groups 
	for(var devGroupId in allDeveloperGroups) {
        if(allDeveloperGroups.hasOwnProperty(devGroupId)) {
		
            //get an existing dev group from the collection of all of the dev groups
            var existingDevGroup = allDeveloperGroups[devGroupId];

            //if an existing dev group is the same length as the one we are checking
            //it is worth comparing the values inside
            if(developerIds.length === existingDevGroup.memberIds.length) {
                
                //assume the arrays are the same
                var same = true;
                
                //check each value (both arrays should be sorted by id)
                for(var j = 0;j < existingDevGroup.memberIds.length;j++) {
                    
                    //compare each dev id in the passed in developerIds with each dev id
                    //in the dev group's member array full of dev ids
                    if(developerIds[j] !== existingDevGroup.memberIds[j]) {
                        
                        //the arrays are not equal
                        same = false;
                        break;
                    }
                }
			
                //if we found two arrays that have the same number of elements and have the values
                if(same === true) {
                    
                    //store the match
                    retVal = existingDevGroup;
                    
                    //stop looking
                    break;
                    
                }//else- the arrays are not the same, move on to the next list
			
		    }//else- the length of the passed in array of dev ids is different than the current dev group
        }
	}

	return retVal;
}
//*****************************************************************************
//                        Debugging related code
//                        ----------------------
// This code has to do with the debugging. 
//*****************************************************************************
/*
 * Prints file info about each of the files in the system
 */
function printAllFiles() {
    
    console.log("All Files:");

    //for every file object 
    for(var file in allFiles) {
        if(allFiles.hasOwnProperty(file)) {
            
            //print some basic file info
            console.log("File: " + allFiles[file].currentName);    
            console.log("ID: " + allFiles[file].id);
            console.log("Parent ID: " + allFiles[file].parentId);

            if(allFiles[file].isDeleted === true) {
                console.log("State: deleted");    
            } else {
                console.log("State: present");
            }
            
            console.log("\n");            
        }
    }
}

/*
 * Prints dir info about each of the files in the system
 */
function printAllDirectories() {

    console.log("All Directories:");
    
    //for every dir object
    for(var dir in allDirs) {
        if(allDirs.hasOwnProperty(dir)) {

            //print some basic dir info
            console.log("Directory: " + allDirs[dir].currentName);    
            console.log("ID: " + allDirs[dir].id);
            console.log("Parent ID: " + allDirs[dir].parentId);

            if(allDirs[dir].isDeleted === true) {
                console.log("State: deleted");
            } else {
                console.log("State: present");
            }

            console.log("\n");            
        }
    }    
}

/*
 * Prints all the path to id mappings
 */
function printAllPathToIdMappings() {
    
    console.log("All Path to ID mappings:");
    
    //for each path to id mapping
    for (var path in pathToIdMap) {
        if(pathToIdMap.hasOwnProperty(path)) {

            //print the path and corresponding id
            console.log("Path: " + path + " ID: " + pathToIdMap[path]);
        }
    }

    console.log("\n");
}

/*
 * Use some of the other helpers to comprehensive debugging
 */
function printAll() {
    printAllPathToIdMappings();
    printAllFiles();
    printAllDirectories()
}

/*
 * Helper to print the state of the doc
 */
function printAllInsertEventsByPos(file) {
	
	var str = "";

    //print the file id before the contents
    console.log("File id: " + file.id);

    //get a files events
    var allInsertEventsByPos = allInsertEventsByFile[file.id];

    //for each row
    for(var i = 0;i < allInsertEventsByPos.length;i++) {

        //for each column in a row
        for(var j = 0;j < allInsertEventsByPos[i].length;j++) {

            //if it is a newline
            if(allInsertEventsByPos[i][j].character === "\n") {

                //add a viewable \n
                str += "\\n";

            } else { //non-newline

                //add the character 
                str += allInsertEventsByPos[i][j].character + " ";				
            }
        }

        //print the current row
        console.log(str);

        //get ready for the next row
        str = "";
    }
}

module.exports = {
    
    //for text related functionality
    deleteText: deleteText,
    insertText: insertText,
    getInsertEventsByPos: getInsertEventsByPos,

    //for file system related functionality
    createFile: createFile,
    createDirectory: createDirectory,
    renameFile: renameFile,
    renameDir: renameDir,
    moveFile: moveFile,
    moveDir: moveDir,
    deleteFile: deleteFile,
    deleteDir: deleteDir,
    deleteFileOrDirectory: deleteFileOrDirectory,
    ignoreThisFileOrDir: ignoreThisFileOrDir,
    loadStorytellerIgnoreFile: loadStorytellerIgnoreFile,

    //for getting and setting the state of the editor 
    getPlaybackData: getPlaybackData,
    setPlaybackData: setPlaybackData,
    getEditorState: getEditorState,
    setEditorState: setEditorState,
    getText: getText,
    isFileOrDirPresent: isFileOrDirPresent,
    getAllFilePaths: getAllFilePaths,
    getAllDirPaths: getAllDirPaths,
    
    //for developer related functionality
    createAnonymousDeveloper: createAnonymousDeveloper,
    overwriteAnonDev: overwriteAnonDev,
    getAllDevsInActiveDevGroup: getAllDevsInActiveDevGroup,
    getAllDevsExceptThoseInActiveDevGroup: getAllDevsExceptThoseInActiveDevGroup,
    createDeveloper: createDeveloper,
    addDeveloperToActiveDeveloperGroup: addDeveloperToActiveDeveloperGroup,
    removeDeveloperFromActiveDeveloperGroup: removeDeveloperFromActiveDeveloperGroup,

    //for branch related functionality
    createRandomBranchId: createRandomBranchId,

    //for debugging
    printAllFiles: printAllFiles,
    printAllDirectories: printAllDirectories,
    printAllPathToIdMappings: printAllPathToIdMappings,
    printAll: printAll
};